回顾
  继承：父子类型的关系
 继承的特点：
   1) 子类继承父类的属性和方法，所有子类共享了
   父类定义的属性和方法，简化了子类的定义
   2) 父类型定义变量可以引用子类的实例，形成
   多态关系，多态系统。
   3) 重写：子类“修改”了父类的行为。
   4) super：在子类方法中调用父类定义的属性和方法
     super() 调用父类的构造器
     this() 调用本类的其它构造器
     
 关于toString()方法
  1) Java 所有的类都继承（间接继承）于Object
    如果类没有声明父类型，就继承于Object
    逻辑上就是“啥都是东西！”
  2) Object 定义的toString()方法被子类继承了
    finalized()
    A 任何对象（东西）都可以用文字描述。
    B 当调用一个对象的toString()方法就返回
      对这个对象的文字描述。
    C 一般在类中要“重写”（修改）为具体的描述
 
 重写 == 覆盖
 
 finalized() 是Object类上定义的方法，在对象
 销毁时候调用一次。不建议重写
 
 避免循环引用      
    
 对象的创建： 使用new 运算
 对象的销毁：当没有任何变量引用这个对象时候
   销毁对象，是有延迟的，不是立即销毁。
 

1 继承与构造器
  1) 构造器不能继承，子类不能继承父类构造器。
  2) 子类“一定”调用父类构造器
    A 如果没有直接调用，Java在子类构造器中，默认
    （自动）调用父类无参数构造器
    B 可以使用super() 调用父类的构造器。
    C 违反了规则有编译错误。
   super() 只能在子类构造器中使用
   super() 只能用在子类构造器的第一行
  
   this() 只能用在构造器中，调用本类的其它构造器
   this() 只能用在构造器的第一行
   this() super() 互斥
   
   this() 的用途 重用构造器
   
   class Airplane{
     int x, y, width,height;
     public Airplane(int x,int y, int w, int h){
     	super();
     	this.x=x;this.y=y;width=w;height=h;
     }
     public Airplane(int w, int h){
        this(0,0,w,h);
        y=-h;
        Random r = new Random();
        x = r.nextInt(285-w);    
     }
   } 

2 对象的实例化过程
  对象的创建过程，也就是对象的属性实例化过程

3 Java的编译器类型检验规则：Java编译器根据变量
  类型检查是否能够访问属性和方法。如果这个变量
  上没有属性或方法的定义， 就会出现编译错误。
  Java在编译时候， 是没有任何对象的！
  对象是在运行期间在堆中创建的。
  简单说：引用变量在运行期间动态绑定到对象。
  在运行期间根据对象的类型调用方法
 
4 Java 只根据变量的类型访问属性
  当父子类型具有相同属性时候，Java根据访问属性
  的变量类型，访问相应的属性。
  
  注意：一般不建议在子类中定义与父类相同的属性
  
  案例：人 与 骗子
  
  
  

















