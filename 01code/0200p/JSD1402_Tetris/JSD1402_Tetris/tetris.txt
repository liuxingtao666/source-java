软件的开发过程

  1) 需求(软件功能的文字描述)
  2) 需求分析(找对象)
  3) 概要设计
    3.1) 数学模型
    3.2) 类的设计
  4) 详细功能的设计
    4.1) 数据初始化
    4.2) 界面绘制
    4.3) 左右移动功能设计
    4.4) 下落功能设计
    

1 明确业务需求
  用自然语言，将业务功能描述清楚
  
Tetris 专用词 俄罗斯方块
Tetromino 专用词 4格方块 

俄罗斯方块的基本规则：
1、一个用于摆放小型正方形的平面虚拟场地，其标准大小：
行宽为10，列高为20，以每个小正方形为单位。 
2、一组由4个小型正方形组成的规则图形，英文称为Tetromino，
中文通称为方块共有7种，分别以S、Z、L、J、I、O、T这7个
字母的形状来命名。

I：一次最多消除四层
J（左右）：最多消除三层，或消除二层
L：最多消除三层，或消除二层
O：消除一至二层
S（左右）：最多二层，容易造成孔洞
Z （左右）：最多二层，容易造成孔洞
T：最多二层

（1）玩家操作有：旋转方块，以格子为单位左右移动方块，
让方块加速落下。
（2）方块移到区域最下方或是着地到其他方块上无法移动时，
就会固定在该处，而新的方块出现在区域上方开始落下。
（3）当区域中某一列横向格子全部由方块填满，则该行会消失
并成为玩家的得分。同时删除的行数越多，得分指数上升。
（4）当固定的方块堆到区域最上方而无法消除层数时，
则游戏结束。
（6）一般来说，游戏还会提示下一个要落下的方块，
熟练的玩家会计算到下一个方块，评估要如何进行。
由于游戏能不断进行下去对商业用游戏不太理想，
所以一般还会随着游戏的进行而加速提高难度。
（7）预先设置的随机发生器不断地输出单个方块到场地顶部


2 业务分析
  找到有哪些业务对象根据图片的分析
  
 窗口
  |-- tetris(俄罗斯方块) 矩形区域
	    |-- score 累计分数
	    |-- lines 销毁的行数
	    |-- wall(墙 20行X10列)
	    |    |-- 20row（行）
	    |         |-- 10 col cell（列）
	    |-- tetromino 正在下落的（4格方块，有7种形态）
	    |      |-- 4 cell
	    |-- nextOne 下一个准备下落的方块 
	           |-- 4 cell

3 数据模型, 一切业务对象转换为数字表示  
  场地按照行列划分为 20×10格子
   格子有属性row, col, color
   
4 类 设计
  Cell
   |-- int row
   |-- int col
   |-- image 贴图
  
  Tetromino 
   |--Cell[] cells
               |-- Cell * 4
  
  Tetris 俄罗斯方块
   |-- Cell[][] wall = 20*10
   |-- Tetromino tetromino 正在下落的方块
   |-- Tetromino nextOne 下一个方块
   |-- int lines
   |-- int score
  
填写初始化代码(构造器)
  功能:
  toString() 

绘制界面: 将对象的"数据"绘制到界面, 界面是数据的表现
  界面不是业务逻辑,
利用API实现界面的绘制工作!
 

5 算法设计，就是如何利用数据的计算实现软件的功能
 
 4格方块的初始形态：I S Z J L T O 
  就在初始数据的数值状态设计
  
  四格方块的下落计算： 就是将每个格子的row+1
  就是将下落业务功能，转换为数字计算实现
  
 左右移动
 
 下落流程控制：控制方块下落与墙之间的控制关系
   1 合理的文字流程描述 
   2 分析文字描述中的功能（动作）为方法
   3 用流程控制语句连接方法实现功能！
   4 严格测试结果！ TestCase 
   
   1) 如果"能够下落", 就下落一步
   2) 否则就"着陆到墙里面"
   3) 着落以后, "销毁充满的行", 并且记分
   4) "检查游戏结束"了吗? 
   5) 如果还能玩，就生成下一个方块
   
 
 左右移动流程控制

 分数计算

 界面的绘制
 
 键盘事件控制
  
 
 旋转流程控制
 
 加速下降流程控制
 
 记分
 
 开始流程控制（Timer）
  主刷新(Timer)频率: 1/100 秒 
 0.5秒执行一次下落(是主刷新的50倍)
 
 利用定时器定时的调用 下落流程
 如果暂停时候, 就不执行下落流程来
 
 实现过程:
 1) 在Tetris类中添加属性 Timer, 用于启动主刷新频率
 2) 在Tetris类中添加属性 level 是下落的间隔次数
   如: 50 表示50次刷新以后,执行一次 下落, 如果减少, 
   加快下落
 3)  在Tetris类中添加属性 stepIndex 是下落计数 
  每当 stepIndex % level == 0 时候 执行一次 下落
 4) 在Tetris类中添加属性  pause 暂停执行状态控制
 5) 在action() 方法添加主刷新Timer的启动
   在主刷新中 添加代码 控制下落
   
 
 暂停流程控制
 设置暂停状态 true
 
 继续流程控制
 
 结束流程控制
 
 修改键盘事件
 
 修改paintScore方法
 
 
 
 Person I;
 Person you;
 
 I.love(you);
 
如何绘制背景图片
 1) 将图片素材文件复制到 com.tarena.tetris 包中
 2) 在Tetris类中声明静态变量 background 
 3) 使用静态代码块 加载磁盘文件到内存对象
    将使用到 图片读取API: ImageIO 
 4) 在paint 方法中绘制背景图片
 
 可能出现的错误:
 1) 文件名/包搞错了!
  
如何绘制 正在下落的方块
 1) 先在action方法中生产 正在下落的方块和下一个方块
 2) 在paint方法中调用 paintTetromino()方法
 3) 在Tetris类中 增加paintTetromino()方法
    将正在下落的4格方块的每个格子逐一绘制出来
 
如何使方块移动
 1) 处理键盘事件(API), 获得用户何时按下 ->  <-
 2) 当按下 -> 按键时候, 执行当前4格方块 向右移动 方法
 3) 向右移动 方法 会改变当前4格方块的每个格子的列坐标
 4) 调用继承于JPanel类的 repaint(), 这个方法会尽快的
  调用 paint()
 5) paint() 会根据当前数据(已经被右移动改变的数据)
  绘制全部面板效果
 6) 用户的感受就是, 方块动了.


















 
 
 
 
 
 
 
 
  
   
   
   
   
   
   
   
   
   
   
   
  
  
  
  
  






