回顾
  分支结构
   if(分支条件)else  
 建议：1) 尽量使用肯定的条件，思考逻辑不容易错！
   如：
      if(! start){
      
      }else{
		//? System.out.println("欢迎您")
      } 
      2) 减少使用else，else里面的逻辑容易错
      3) 嵌套，最好不超过2层
      4) 最好代码块不要超过一个屏幕
  多路分支：
    A if else if else 根据任意条件分支
    B switch case 根据整数进行分支，性能好
        根据业务需要，使用break
      
 for 循环：经典使用是计数循环
   i：index：索引号，序号  的缩写
    设计for循环：
     1）初始
     2）结束
     3）递增
     4）循环
 
 while 循环 经典用法：与次数无关，在循环体开始时候
    检查循环条件。

1  do while 循环 经典用法：与次数无关，在循环体
   结束时候检查循环条件
  语法：
    do{
      //循环体
    }while(循环体条件);//如果条件返回true再次执行
  案例：输入数据合理性检查，如：百分制输入检查
    如：从控制台输入分数：
      -5 不可以 
      101 不可以
      85 可以通过
  分析：只能在输入以后反复检查合理性，直到合理了
  才结束检查。
  设计：
    输入：score 
    输出：合理的分数
    算法：
     1) 从控制台输入分数
     2) 如果分数不合理返回(1)
     3) 输出合理分数。
   Scanner console = new Scanner(System.in);
   int score;
   do{ 
       System.out.print("输入分数：");
       score=console.nextInt();
   }while(score<0 || score>100);
   System.out.println(score);
   
2  循环的替代性（非经典用法）  
 1) 死循环：循环的条件是true，循环会一直执行
    经常在死循环中配合 break 语句，适当时候结束循环
  常见的死循环
   while(true){
     //循环体
   } 
   for(;;){
     //循环体
   }
   不常见写法
   for(;true;){
     //循环体
   }
   do{
     //循环体
   }while(true);
   
  2)for完全可以替代while 
    while(循环条件){
      //循环体
    }
   等价
    for(;循环条件;){
      //循环体
    }
  3) while 也可以代替 for
    for(初始化;循环条件;递增表达式){
      //循环体
    }   
    基本等价于，差一点：循环变量的作用域不同！
    //初始化
    while(循环条件){
      //循环体
      //递增表达式
    }
  4) while 代替 do while
	do{
	  //循环体
	}while(循环继续条件);  
    等价
    while(true){
      //循环体
      if(! 循环继续条件){
        break;
      }
    }

3  循环的选择问题
  1) for: 与个数次数有关的循环
  2) while: 与次数无关，循环条件在循环体开始检查
  3) do while: 与次数无关，循环条件在循环体最后检查
  4) 以上都不是（如：在循环体中间检查循环条件）
    使用死循环配合break语句。 
  5) 如果不能确定使用哪种循环就使用“死循环”
  

4 对象简介
  1) 什么是对象
     Object == 物件 == 东西 == 对象
   什么是东西：一个存在的具体事物 == 啥都是东西
   一切皆对象 == Everything is Object.
  
  东西使用代词引用和操作，代词本身不是东西本身
  
  引用类型变量，就是代词

5 数组是对象，数组是一个东西
  1) 数组变量：指代数组的代词
  2) 数组：是一组元素组成的一个整体（一个东西）
  3) 数组的元素：是数组中每个个体
  
  数组的语法现象：
  1) 声明和初始化数组变量
  2) 如何创建数组，如何创建数组整体这个东西
  3) 如何访问数组中的元素。
 
 详细   
  1) 声明和初始化数组变量
     语法：   
         数据类型[] 变量名;
   如： 
      int[] ary;
    注意：如果声明变量直接访问编译错误，没有初始化
   初始化语法：赋值
     可以赋值为null(空)，表示没有数组，变量是空的！
      ary = null;
   如果访问：直接输出结果“null”
    如果访问元素，出现运行异常：空指针异常！
    原因是没有数组造成的问题
    
  2) 如何创建数组，如何创建数组整体这个东西
   语法：3种
    1) 第一种 直接初始化数组的元素
    new 类型[]{元素0,元素1,元素2 ...}
    如：int[] ary = new int[]{3,4,5};
    //               下标      0 1 2
    2) 使用长度创建数组
    new 类型[长度]
    如：int[] ary2 = new int[3];//{0,0,0} 
    使用长度创建数组，数组的元素自动初始化为“零”
    “零”: 0  0.0  '\u0000' false null
    '\u0000' 是编号为0的字符，是不可显示字符
    如果输出的话，可能在这个字符以后不能输出了
    可以转换为int输出为0
    
    3) 静态初始化，相当于(1)的简化形式
    类型[] 变量 = {元素0,元素1,元素2...}
     如：int[] ary3 = {3,4,5};//相当于省略new int[]
   静态初始化：只能用于声明变量之间初始化！
   
   int[] a;
   a = {4,5,6};//编译错误
   
   如何显示全部数组的内容
   数组迭代（遍历）：将数组的每个元素逐一处理一遍
   int[] ary1 = new int[]{3,5,7,2,6}; 
   //                     0 1 2 3 4 长度5
   访问数组元素 ary1[i] i = 0 1 2 3 4
   for(int i=0; i<5 ; i++){
     // i = 0 1 2 3 4
     System.out.print(ary1[i]+" ")
   }
  
  3) 如何访问数组中的元素。   
    A 使用[下标] 可以读写数组的元素
      如： int[] ary = {4,5,6};
      int a = ary[0];//读取数组元素
      ary[0] = 8;//写数组元素
    B 下标范围：0 1 2 ... length-1 长度-1
    如：  int[] ary = {4,5,6}; 
     下标是：0 1 2 一个3个元素
    注意：如果超范围访问，会出现运行异常：下标越界
     int b = ary[3];
    C 使用length属性可以获得数组的长度
    
  数组的用途：在软件中代表一组类型一致的数据
   如：一群僵尸，一群植物，一群飞机等
   
6 方法Method：就是数学函数 y=f(x)
   f:Function 功能！
   方法：
    1) 方法是软件中功能的封装，是软件中的动作
    2) 方法是算法，是封装了数据计算过程
  1) 方法的语法：3个要素：返回值，方法名，参数
     A 方法必须在类中声明，不能在方法中定义方法
     B 方法的定义
       修饰词  返回值类型 方法名(参数列表){
       //方法体
       //方法体就是方法的计算过程
       //如果方法声明了返回值类型，就必须使用
       //return 语句返回结果   
    }
     C 修饰词 是指方法可用范围，在面向对象详细讲
     D 返回值：Java方法必须定义返回值，如果不没有
     返回值，必须使用void 
     E 参数列表: 是方法计算过程的输入条件，前提
     条件。
     
   业务案例：解决碰撞检测问题 
    分析：
    设计：方法 返回值 方法名 参数
     1) 输入参数：x,y,r,x1,y1
     2) 输出返回值：boolean 类型 true 撞上
     3) 方法名：hit 碰，与功能相同的名字
     4) 方法体：算法
       a = x1-x;
       b = y1-y;
       c = Math.sqrt(a*a+b*b);
       return c<r;
     5) 使用return 返回结果
      
   案例：计算 fibonacci 数列的第n项
   黄金分割数列: 黄金分割数：0.618
  数列：1  1  2  3  5  8  13  21  ...
   f(n-1)/f(n) 大约是 0.618
  分析：
   1) 输入 n
   2) 输出 第n项的值
   3) 算法: 从前加到第n项 得到结果。
       初始 i = 3, f1=f2=fn=1;
       结束 i <= n
       递增 i++
       循环体 
       fn = f1+f2;
       f1 = f2;
       f2 = fn;
   4) 方法封装
     A 返回值：long    
     B 参数：int n
     C 方法名: f
     D 方法体：参考前面的算法
     E 返回值 return fn;
     
  序号       1  2  3  4  5  6  7   8
  f(n)   1  1  2  3  5  8  13  21  ... 
  n = 8                        ^
         f1+f2=fn     
            f1+f2=fn
               f1+f2=fn
                  f1+f2=fn
                     f1+f2=fn
                        f1+f2=fn
      
      
      
7 Arrays 类中提供了数组相关的工具算法  
  1) toString() 连接数组内容为字符串，
     用于便捷的输出数组内容
  2) equals 方法用于比较两个数组内容是否一样
   如：标准答案: char[] answer = {'A','C','D'}
   用户输入：char[] input1 = {'A','B','C','D'}
           char[] input2 = {'A','C','D'}
  
  3) Arrays.sort()方法可以对数组进行由小到大排序
  4) 二分查找 binarySearch 方法
     也称为折半查找 
  
  假如如下人住店
   如： Tom  Andy  Jerry John Wang 
       0    1      2     3    4 
  查找：Andy 住哪里, 找到返回房间号 1 找到
       Jerry 住哪里, 找到返回房间号 2 找到
       Tom 住哪里, 找不到，返回负数！
       找不到Tom是一个错误的结果！
  采用2分查找 
  
  2分查找必须在已经排序的数组上查找，否则
  结果不稳定（是错误的结果）
  
  二分查找结果是数组的下标位置，如果是负数
  表示没有找到
   
      
  
  
  
  
  
  
  
  
  
  
  
  
  
  
      
      
   
   
   
   
      