java中的多线程

进程:
   操作系统(OS) 可以同时运行多个任务(应用程序)，每一个应用程序称为一个进程。有独立的内存空间。

线程:
   在一个进程中(应用程序)，可以同时运行多个任务，每一个任务称为一个线程。他们共享同一块内存。

并发:
   多个线程或进程都是并发操作的。
   多个线程看似是同时运行的，实际上大家都是走走停停的。OS会将CPU划分若干的时间片段，并将每一块时间片段尽可能均匀的分配给每一个线程，获取时间片段的线程被CPU执行，其它线程等待。
   这样的现象称为并发。计算机中没有绝对的同时运行。

java中创建线程的两种方式:
1:继承Thread重写run方法。
  run方法中定义的内容为线程中要执行的任务代码。

同步 : 代码的运行有先后顺序。  
异步 : 各运行各的。

线程在启动后，会将自身纳入线程调度机制。线程调度机制会将CPU划分为若干的时间片段，尽可能均匀的分配给每一个线程，获取时间片段的线程被CPU运行，其它线程等待。从而
实现多线程并发操作。



线程                         剧组         
线程调度                    经纪人
时间片段                    档期
cpu                         葛大爷


线程创建的第二种方式:
使得线程与其运行的任务分离开。

定义线程体(线程要执行的任务代码)
实现Runnable接口。


线程在运行过程中可能会产生阻塞现象，其中之一就是Sleep阻塞

使用的是Thread提供的静态方法:

static void sleep(long ms)
使当前线程进入睡眠阻塞指定毫秒。超时后线程会自动进入Runnable状态。

sleep方法要求捕获中断异常，出现的情况是:
当前先出处于睡眠阻塞时，若被其它线程调用interrpute()方法中断时，会抛出该异常。


进程结束:
当一个进程中的所有前台线程全部结束后，进程结束。

后台线程:守护线程
守护线程通常会运行做一些基础服务支撑或数据供供给使用。

GC运行在守护线程上的。
我们的程序启动起来是，OS会分配一个进程来运行，而我们的JVM运行起来后，会启动一个守护线程来运行GC，再启动一个线程来运行main方法。

并发运行的线程只要时间片段用完，无论运行到哪里都要停止。

多线程不可控因素:
线程调度将时间片段分配给哪个线程。
时间片段的具体时间。

public boolean getMoney(int money){
   
   if( money <= count){
      count = count - money;
      save(count);
      return true;
   }
   return false;
}


多线程并发访问同一资源时，会产生线程安全问题。
解决多线程并发安全问题的办法是:将异步的操作变为同步的.

synchronized关键字
使用该关键字修饰方法后，该方法是一个同步方法。多线程不能同时进入到方法内部。

若一个对象的两个方法被synchronized修饰，那么这两个方法又是互斥的。
同步块
synchronized(同步监视器){
  需要同步的代码片段
}
同步块可以有效的缩小同步范围，从而提高并发执行效率。

使用同步块，必须要保证多线程看到的同步监视器这个对象是同一个！


线程安全的                非线程安全的
StringBuffer              StringBuilder
Vector                     ArrayList
Hashtable                 HashMap


t1   builder.append("helloworld")
t2   builder.append("thinking in java");




