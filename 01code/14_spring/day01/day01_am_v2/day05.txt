一、Hibernate的高级特性
	1、二级缓存
		1）什么是二级缓存
			Hibernate在创建SessionFactory时，会给这个
			工厂分一个内存空间，用于存储Session之间
			共享的数据，这个内容空间就是二级缓存，也
			称SessionFactory级缓存，该缓存由
			SessionFactory管理。
			类似于一级缓存，二级缓存中存的也是独立的
			对象，只是这些对象是Session间可以共享的。
			注意：二级缓存是默认关闭的。
		2）什么时候用二级缓存
			如果有数据是多个线程一起频繁访问的，并且
			这些数据不经常修改，那么这类数据可以使用
			二级缓存来存储。
			--多个线程频繁访问
			--不经常修改
		3）使用步骤
			a、引入二级缓存驱动包ehcache.jar。
			b、引入二级缓存配置文件ehcache.xml，
				并配置二级缓存参数。
			c、在hibernate.cfg.xml中，开启二级缓存，
				并指定二级缓存驱动类。
			d、在hbm.xml中对这个对象开启二级缓存。
		4）二级缓存的管理
			SessionFactory.evict(Class);
			可以将某类型数据从缓存中移除。
	2、查询缓存
		1）什么是查询缓存
			查询缓存可以看成是特殊的二级缓存，它占用的
			是二级缓存的空间，并且也是由SessionFactory
			负责管理，它缓存的数据也是可以被多个Session
			共享的。
			查询缓存可以缓存任何类型的数据，如集合、数字
			等。实际上查询缓存是按照hql来进行缓存的，即
			如果2次使用同样的hql进行查询，那么第二次查询
			可以从查询缓存中取出值，而不是访问数据库。
		2）什么时候用查询缓存
			如果项目中频繁的使用同一个hql进行查询，
			那么可以考虑使用查询缓存。
		3）使用步骤
			a、开启二级缓存
			b、在hibernate.cfg.xml中开启查询缓存
			c、查询前设置开启查询缓存
				query.setCacheable(true);
		4）查询缓存的管理
			SessionFactory.evictQueries();
	
二、并发处理
	1、什么是并发处理
		如果多个线程同时访问一份数据，并且同时修改/
		删除这份数据，有可能导致数据有误，那么这种
		多线程同时修改数据导致的问题，称之为并发
		问题，对这种问题的解决称之为并发处理。
	2、并发处理的方式
		采用加锁的方式来处理并发问题。
		1）悲观锁
		2）乐观锁
	3、悲观锁（排队）
		悲观锁机制，悲观的认为所有的线程访问数据库，
		都存在并发问题，都需要进行控制。于是它将每一
		次访问的数据都加锁，那么其他线程如果同时访问
		时，需要等待这个锁的释放，才能继续访问，通过
		锁实现的排队机制，称之为悲观锁。
		优点：安全性高
		缺点：效率低
		Hibernate实现原理：
			Hibernate在查询每一个数据时，都使用数据库
			的加锁机制，给这个数据加锁，即在查询的sql
			后追加for update。
	4、乐观锁（校验）
		乐观锁机制，它乐观的认为所有的线程访问数据
		都不会有并发问题，而不去加以控制。但在更新
		这条数据时它会采取校验，即判断这条数据是否
		在我查询时被其他线程改变了，如果是则放弃当前
		对该数据的修改。
		优点：效率高
		缺点：客户体验差
		Hibernate实现原理：
			Hibernate要求对加锁的表追加版本字段，然后
			每次修改前先校验版本是否变化，若变化则说明
			数据被其他线程修改了，那么就放弃本次修改。
			若没变化则说明数据没有被其他线程修改，那么
			本次修改生效，并且同时将版本+1.
	5、如何选择锁
		1）并发量大时，选择乐观锁，避免等待时间过长
		2）并发量小时，可以选择悲观锁。

三、修改时遇到的问题
	1、由于使用Hibernate修改，调用session.update(obj)
		方法时，它会自动的根据hbm.xml生成sql去执行，
		而hbm.xml中设置的所有列都会被拼入这个update
		语句，导致了一些问题。
		即如果页面上只想更新3个字段，而配置文件中却
		配置了20个字段，那么update语句中将包含所有
		的这些字段的修改，当执行update时会导致原来
		的一些默认值更新为null。
	2、如何解决
		1）在表单中追加hidden，将其他不需要更新的所有
			字段值都放入hidden，提交时一并提交给Action。
		2）在hbm.xml中，属性配置property中追加属性
			update="false"，那么在Hibernate自动拼update
			语句时，将不会拼当前的字段。
		*3）可以在hbm.xml中，class标记上追加属性
			dynamic-update="true"，则Hibernate在自动
			拼sql时会判断字段是否为null，对于为null的
			字段将不拼入此update语句。
			这种方式要求传入的对象是持久态的。
	

