============角色管理==============
一、重构查询
	分析：
			查询角色同时，需要连带查询出权限。而角色
			和权限具有多对多的关系，关系体现在中间表
			role_privilege上。但是由于权限数据存在于
			privileges.xml中，不是存在表中，因此Hibernate
			无法解决这种关联映射。因此去掉权限数据的话，
			剩下的角色和中间表应该具有一对多关系。	
	*1、Entity
		1）追加角色权限中间表实体类
			--追加联合主键类型RolePrivilegeId
			--在实体类中使用这个类型声明id
		2）追加角色权限中间表映射关系文件hbm.xml
		3）在角色实体类中追加集合属性，封装角色权限
			中间表数据
		4）在角色映射关系文件中配置2者的一对多关系
	2、DAO
	3、Action
	4、struts.xml
	5、JSP
		<s:iterator value="rolePrivileges" status="s">
			<!-- 循环内容，栈顶是RolePrivilege -->
			<s:if test="#s.index==0">
				<s:property value="privilegeName"/>
			</s:if>
			<s:else>
				,<s:property value="privilegeName"/>
			</s:else>
		</s:iterator>

二、重构增、删、改
	1、先重构DAO中增、删、改的方法
	2、分别完成增、删、改的功能
		1）使用时联合主键时，联合主键包含了关联字段，
			导致级联添加失效，所以对于增加、修改不能
			进行级联，删除可以。
		2）修改时，由于先修改了Role，导致角色进行了
			持久化。之后我们通过hql自主查询中间表，
			此时使用了role.getId做参数，这个行为
			会触发主表对子表关联字段的维护，导致
			试图将中间表role_id更新为null，会报错。
			使用inverse="true"可以解决。

补充：
	1、联合主键的使用步骤
		1）创建一个联合主键类型（JavaBean）
			--创建一个类，实现接口Serializable
			--将联合主键的字段作为属性加入类中
		2）实体类中增加主键
			--增加一个联合主键类型的属性，作为
				这个实体类的主键属性。
			--这个实体类中不需要直接体现任何一个
				联合主键字段
		3）在映射关系文件中，声明联合主键
			<composite-id 
				name="属性名" class="联合主键类型">
				<key-property 
					name="联合主键中的属性1" 
					type="类型" 
					column="联合主键字段1"/>
				<key-property 
					name="联合主键中的属性2" 
					type="类型" 
					column="联合主键字段2"/>
			</composite-id>